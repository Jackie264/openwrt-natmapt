#!/bin/sh /etc/rc.common

. "${IPKG_INSTROOT}/lib/functions/network.sh"

START=72
STOP=90
USE_PROCD=1

# natmap
[ -x "$(command -v  nft)" ] && FW='fw4' || FW='fw3'
NAME=natmap
GLOBALSECTION=global
NATMAPSECTION=natmap
PROG=/usr/bin/$NAME

STATUS_PATH=/var/run/natmap

config_load "$NAME"


# define global var: DEF_WAN DEF_WAN6 NIC_* NIC6_*
define_nic() {
	local dev sub addr
	# get all active NICs
	for dev in $(ip -o link|sed -En "s|^\d:\s*([^:]+):.*|\1|gp"); do
		#ipv4
		sub=$(ip -o -4 addr|sed -En "s|.*${dev}\s+inet\s+([0-9\./]+).*|\1|gp")
		eval "NIC_${dev//-/_}=\"\$sub\""
		#ipv6
		sub=$(ip -o -6 addr|sed -En "s|.*${dev}\s+inet6\s+([A-Za-z0-9\./:]+).*|\1|gp")
		# ref: https://github.com/openwrt/openwrt/blob/main/package/base-files/files/lib/functions/network.sh#L53 #network_get_subnet6()
		for _ in $sub; do
			for addr in $sub; do
				case "$addr" in fe[8ab]?:*|f[cd]??:*)
					continue
				esac
				sub=$addr; break
			done
			# Attempt to return first non-fe80::/10 range
			for addr in $sub; do
				case "$addr" in fe[8ab]?:*)
					continue
				esac
				sub=$addr; break
			done
			# Return first item
			for addr in $sub; do
				sub=$addr; break
			done
		done
		eval "NIC6_${dev//-/_}=\"\$sub\""
	done
	# get default gateway 0.0.0.0/::
	network_find_wan DEF_WAN true
	network_find_wan6 DEF_WAN6 true

	return 0
}
define_nic

load_interfaces() {
	config_get interface "$1" interface
	config_get enable "$1" enable 1

	[ "${enable}" = "1" ] && interfaces=" ${interface} ${interfaces}"
}

# define global var: GLOBAL_*
define_global() {
	[ "$2" == "0" ] || { >&2 echo "$(basename $0): section $1 validation failed"; return 1; }

	local error=0
	local v ucivv="enable def_tcp_stun def_udp_stun def_http_server def_interval"
	for v in $ucivv; do
		[ -z "$(config_get $1 $v)" ] && err_msg__empty $1 $v && let error++
		eval "config_get GLOBAL_$v \$1 \$v"
	done

	[ "$error" -gt 0 ] && return 1 || return 0
}

validate_section_global() {
	uci_load_validate "$NAME" "$GLOBALSECTION" "$1" "$2" \
		'enable:bool:0' \
		'def_tcp_stun:hostname' \
		'def_udp_stun:hostname' \
		'def_http_server:hostname' \
		'def_interval:and(uinteger, min(1)):10' \
		'test_port:and(port, min(1))'
}

validate_section_natmap() {
	uci_load_validate "$NAME" "$NATMAPSECTION" "$1" "$2" \
		'enable:bool:0' \
		'interval:and(uinteger, min(1))' \
		'stun_server:hostname' \
		'http_server:hostname' \
		'comment:string' \
		'udp_mode:bool:0' \
		'family:or("ipv4", "ipv6"):ipv4' \
		'interface:network' \
		'port:and(port, min(1))' \
		'forward_mode:bool:0' \
		'forward_method:or("dnat", "via"):via' \
		'natloopback:bool:1' \
		'forward_target:host' \
		'forward_port:and(port, min(1))' \
		'notify_script:file'
}

natmap_instance() {
	[ "${enable}" = 0 ] && return 0

	procd_open_instance "$1"
	procd_set_param command "$PROG" \
		${interval:+-k "$interval"} \
		${stun_server:+-s "$stun_server"} \
		${http_server:+-h "$http_server"} \
		${port:+-b "$port"} \

	[ "${family}" = ipv4 ] && procd_append_param command -4
	[ "${family}" = ipv6 ] && procd_append_param command -6
	[ "${udp_mode}" = 1 ] && procd_append_param command -u

	[ -n "${interface}" ] && {
		local ifname

		network_get_device ifname "$interface" || ifname="$interface"
		procd_append_param command -i "$ifname"
		procd_append_param netdev "$ifname"
	}

	[ -n "${forward_target}" ] && procd_append_param command -t "$forward_target" -p "$forward_port"

	[ -n "${notify_script}" ] && procd_set_param env "NOTIFY_SCRIPT=${notify_script}"
	procd_append_param command -e /usr/lib/natmap/update.sh

	procd_set_param respawn
	procd_set_param stdout 1
	procd_set_param stderr 1

	procd_close_instance
}

clear_status_files() {
	mkdir -p "${STATUS_PATH}" 2>/dev/null
	find "${STATUS_PATH}" -type f -print0 | xargs -0 rm -f --
}

# err_msg__empty <section> <option>
err_msg__empty() {
	>&2 echo "$(basename $0): section $1 option $2 cannot be empty"
}

launcher() {
	[ "$2" = 0 ] || { >&2 echo "$(basename $0): section $1 validation failed"; return 1; }
	# global options
	[ "$udp_mode" = 1 ] \
		&& echo ${stun_server:=$GLOBAL_def_udp_stun} >/dev/null \
		|| echo ${stun_server:=$GLOBAL_def_tcp_stun} >/dev/null
	echo ${http_server:=$GLOBAL_def_http_server} \
	${interval:=$GLOBAL_def_interval} >/dev/null
	# natmap options
	local error=0
	#[ -z "$interface" ] && default gateway
	[ -z "$port" ] && err_msg__empty $1 port && let error++
	if   [ "$forward_mode" = 1 ]; then
		[ -z "$forward_target" ] && err_msg__empty $1 forward_target && let error++
		[ -z "$forward_port" ] && err_msg__empty $1 forward_port && let error++
	elif [ "$forward_mode" = 0 ]; then
		unset forward_target forward_port
	fi
	[ "$error" -gt 0 ] && return 1

	natmap_instance "$1"
}

service_triggers() {
	local interfaces

	procd_add_reload_trigger "${NAME}"

	config_foreach load_interfaces natmap

	[ -n "${interfaces}" ] && {
		for n in $interfaces ; do
			procd_add_reload_interface_trigger $n
		done
	}

	procd_add_validation validate_section_natmap
}

start_service() {

	clear_status_files

	config_foreach validate_section_global "$GLOBALSECTION" define_global || return $?
	[ "${GLOBAL_enable:=0}" == "0" ] && return 1

	config_foreach validate_section_natmap "$NATMAPSECTION" launcher
}

reload_service() {
	stop
	start
}

service_stopped() {
	clear_status_files
}
